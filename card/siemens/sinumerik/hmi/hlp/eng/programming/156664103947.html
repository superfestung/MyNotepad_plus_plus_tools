<html>
  <head>
    
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Oscillation controlled by synchronized actions (OSCILL): Further information</title>
  </head>
  <body id="bodyID">
    <div id="nsbanner">
      <div id="TitleRowDefault">
        <h1 class="title">Oscillation controlled by synchronized actions (OSCILL): Further information</h1>
      </div>
    </div>
    <div id="nstext" valign="bottom">
      <p>
      </p>
      <a name="block_1">
      </a>
      <h3 class="BlocktitleFirst">More information</h3>
      <h4 class="Blocklabel">Define oscillation parameters</h4>
      <h4 class="Blocklabel">
        <b>Assignment of oscillating and infeed axes: OSCILL</b>
      </h4>
      <p>
        <code>OSCILL[&lt;oscillating axis>]=(&lt;infeed axis1>,&lt;infeed axis2>,&lt;infeed axis3>)</code>
      </p>
      <p>The axis assignments and the start of the oscillation movement are defined with the "OSCILL" command.   </p>
      <p>Up to 3 infeed axes can be assigned to an oscillating axis.</p>
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td>
            <font size="1px">
            </font>
          </td>
        </tr>
      </table>
      <table class="safety" border="1" bgcolor="#eeeeee">
        <colgroup>
          <col width="5%">
          <col width="95%">
        </colgroup>
        <tr>
          <td>
            <b>Note</b>
          </td>
        </tr>
        <tr>
          <td>
            <p class="safety">Before oscillation starts, the synchronization conditions must be defined for the behavior of the axes.</p>
          </td>
        </tr>
      </table>
      <h4 class="Blocklabel">
        <b>Define infeeds: POSP</b>
      </h4>
      <p>
        <code>POSP[&lt;infeed axis>]=(&lt;end position>,&lt;partial length>,&lt;mode>)</code>
      </p>
      <p>The following are declared to the control with the "POSP" command:   </p>
      <ul>
        <li>
          <p>Complete infeed (with reference to end position)</p>
        </li>
        <li>
          <p>The length of the partial infeed at the reversal point or in the reversal area</p>
        </li>
        <li>
          <p>The partial infeed response when the end position is reached (with reference to mode)</p>
        </li>
      </ul>
      <a id="table_ebb0b809-8beb-4d8d-b81f-d162fff34afa">
      </a> <a id="table_0"></a> <a id="table_ebb0b809-8beb-4d8d-b81f-d162fff34afa"></a> <a id="table_0"></a> <p><table width="100%" cellspacing="0" cellpadding="0" class="table_default" border="1"><colgroup><col width="16.6%"><col width="83.3%"></colgroup><tr valign="top"><td><p type="p_table_l" style="margin-top: 4px" align="left">Mode = 0</p></td><td><p type="p_table_l" style="margin-top: 4px" align="left">The distance-to-go to the destination point for the last two partial infeeds is divided into two equal steps (default setting).</p></td></tr><tr valign="top"><td><p type="p_table_l" style="margin-top: 4px" align="left">Mode = 1</p></td><td><p type="p_table_l" style="margin-top: 4px" align="left">All partial infeeds are of equal size. They are calculated from the complete infeed.</p></td></tr></table></p><h4 class="Blocklabel">Define motion-synchronized actions</h4><p>The motion-synchronous actions listed below are used for general oscillation.   </p><p>You are given example solutions for individual tasks, which you can use as modules for creating user-specific oscillation movements</p><table cellpadding="0" cellspacing="0" border="0"><tr><td><font size="1px"></font></td></tr></table><table class="safety" border="1" bgcolor="#eeeeee"><colgroup><col width="5%"><col width="95%"></colgroup><tr><td><b>Note</b></td></tr><tr><td><p class="safety">In individual cases, the synchronization conditions can be programmed differentially.</p></td></tr></table><p>Keywords:</p><a id="table_ef9e6cd6-7751-4917-8514-3f05dd320bd8"></a> <a id="table_1"></a> <a id="table_ef9e6cd6-7751-4917-8514-3f05dd320bd8"></a> <a id="table_1"></a> <p><table width="100%" cellspacing="0" cellpadding="0" class="table_default" border="1"><colgroup><col width="35.0%"><col width="65.0%"></colgroup><tr valign="top"><td><p type="p_table_l" style="margin-top: 4px" align="left"><code>WHEN … DO …</code>   </p></td><td><p type="p_table_l" style="margin-top: 4px" align="left">when…, do…</p></td></tr><tr valign="top"><td><p type="p_table_l" style="margin-top: 4px" align="left"><code>WHENEVER … DO</code>   </p></td><td><p type="p_table_l" style="margin-top: 4px" align="left">whenever…, do…</p></td></tr></table></p><p>Functions</p><p>You can implement the following functions with the language resources described in detail below:</p><ol><li><p>Infeed at reversal point.</p></li><li><p>Infeed at reversal area.</p></li><li><p>Infeed at both reversal points.</p></li><li><p>Stop oscillation movement at reversal point.</p></li><li><p>Restart oscillation movement.</p></li><li><p>Do not start partial infeed too early.</p></li></ol><p>The following assumptions are made for all examples of synchronized actions presented here:</p><ul><li><p>Reversal point 1 &lt; reversal point 2</p></li><li><p>Z = oscillating axis</p></li><li><p>X = infeed axis</p></li></ul><table cellpadding="0" cellspacing="0" border="0"><tr><td><font size="1px"></font></td></tr></table><table class="safety" border="1" bgcolor="#eeeeee"><colgroup><col width="5%"><col width="95%"></colgroup><tr><td><b>Note</b></td></tr><tr><td><p class="safety">For more details, see the "Motion-synchronous actions" section.</p></td></tr></table><h4 class="Blocklabel">Assign oscillating and infeed axes as well as partial and complete infeed</h4><p>Infeed at reversal area:</p><p>The infeed motion must start within a reversal area before the reversal point is reached.     </p><p>These synchronized actions inhibit the infeed movement until the oscillating axis is within the reversal area.</p><p>The following instructions are used subject to the above assumptions:</p><a id="table_19c3c764-7100-4d5f-9a90-965924efcde5"></a> <a id="table_2"></a> <a id="table_19c3c764-7100-4d5f-9a90-965924efcde5"></a> <a id="table_2"></a> <p><table width="100%" cellspacing="0" cellpadding="0" class="table_invisible" border="0"><colgroup><col width="75.5%"><col width="24.5%"></colgroup><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Reversal range 1:</p>WHENEVER $AA_IM[Z]>$SA_OSCILL_RESERVE_POS1[Z]+ii1 DO $AA_OVR[X] = 0</td></tr><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Whenever the actual position of the oscillating axis in the MCS is greater than the start of reversal range 1, then set the axial override of the infeed axis to 0%.</p></td></tr><tr valign="top"><td> </td><td> </td></tr><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Reversal range 2:</p>WHENEVER $AA_IM[Z]&lt;$SA_OSCILL_RESERVE_POS2[Z]+ii2 DO $AA_OVR[X] = 0</td></tr><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Whenever the actual position of the oscillating axis in the MCS is smaller than the start of reversal range 2, then set the axial override of the infeed axis to 0%.</p></td></tr></table></p><p>Infeed at reversal point:</p><p>As long as the oscillating axis has not reached the reversal point, the infeed axis does not move.   </p><p>The following instructions are used subject to the above assumptions:</p><a id="table_47a4ad31-e231-487c-af3c-295a5e5c6f05"></a> <a id="table_3"></a> <a id="table_47a4ad31-e231-487c-af3c-295a5e5c6f05"></a> <a id="table_3"></a> <p><table width="100%" cellspacing="0" cellpadding="0" class="table_invisible" border="0"><colgroup><col width="31.3%"><col width="68.7%"></colgroup><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Reversal range 1:</p>WHENEVER $AA_IM[Z]&lt;>$SA_OSCILL_RESERVE_POS1[Z] DO $AA_OVR[X]=0 $AA_OVR[Z]=100</td></tr><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Whenever the actual position of oscillating axis Z in MCS is greater or less than the position reversal point 1, then set the axial override of the infeed axis X to 0% and the axial override of the oscillating axis Z to 100%.</p></td></tr><tr valign="top"><td><p type="p_table_l" style="margin-top: 4px" align="left"></p> </td><td><p type="p_table_l" style="margin-top: 4px" align="left"></p> </td></tr><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Reversal range 2:</p><p type="p_table_l" align="left">For reversal point 2:</p>WHENEVER $AA_IM[Z]&lt;>$SA_OSCILL_RESERVE_POS2[Z] DO $AA_OVR[X]=0 $AA_OVR[Z]=100</td></tr><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Whenever the actual position of oscillating axis Z in MCS is greater or less than the position reversal point 2, then set the axial override of the infeed axis X to 0% and the axial override of the oscillating axis Z to 100%. </p></td></tr></table></p><p>Stop oscillation movement at the reversal point:</p><p>The oscillating axis is stopped at the reversal point, the infeed motion starts at the same time. The oscillating motion is continued when the infeed movement is complete.</p><p>At the same time, this synchronized action can be used to start the infeed movement if this has been stopped by a previous synchronized action, which is still active.</p><p>The following instructions are used subject to the above assumptions:</p><a id="table_ae03f22d-4487-4c11-84f8-38a97f4a3172"></a> <a id="table_4"></a> <a id="table_ae03f22d-4487-4c11-84f8-38a97f4a3172"></a> <a id="table_4"></a> <p><table width="100%" cellspacing="0" cellpadding="0" class="table_invisible" border="0"><colgroup><col width="31.7%"><col width="68.3%"></colgroup><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Reversal range 1:</p>WHENEVER $SA_IM[Z]==$SA_OSCILL_RESERVE_POS1[Z] DO $AA_OVR[X]=0 $AA_OVR[Z]=100</td></tr><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Whenever the actual position of the oscillating axis in the MCS is the same as the reversal position 1, then set the axial override of the oscillating axis to 0% and the axial override of the infeed axis to 100%.</p></td></tr><tr valign="top"><td> </td><td> </td></tr><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Reversal range 2:</p>WHENEVER $SA_IM[Z]==$SA_OSCILL_RESERVE_POS2[Z] DO $AA_OVR[X]=0 $AA_OVR[Z]=100</td></tr><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Whenever the actual position of the oscillating axis Z in the MCS is the same as the reversal position 2, then set the axial override of the oscillating axis X to 0% and the axial override of the infeed axis to 100%.</p></td></tr></table></p><h4 class="Blocklabel">Online evaluation of reversal point</h4><p>If there is a main run variable coded with <code>$$</code> on the right of the comparison, then the two variables are evaluated and compared with one another continuously in the IPO cycle.   </p><table cellpadding="0" cellspacing="0" border="0"><tr><td><font size="1px"></font></td></tr></table><table class="safety" border="1" bgcolor="#eeeeee"><colgroup><col width="5%"><col width="95%"></colgroup><tr><td><b>Note</b></td></tr><tr><td><p class="safety">Please refer to Section "Motion-synchronized actions" for more information.</p></td></tr></table><p>Oscillation movement restarting:</p><p>The purpose of this synchronized action is to continue the movement of the oscillating axis on completion of the part infeed movement.</p><p>The following instructions are used subject to the above assumptions:</p><a id="table_1149d5b4-984c-425b-bc1c-acfc5a154b9b"></a> <a id="table_5"></a> <a id="table_1149d5b4-984c-425b-bc1c-acfc5a154b9b"></a> <a id="table_5"></a> <p><table width="100%" cellspacing="0" cellpadding="0" class="table_invisible" border="0"><colgroup><col width="93.7%"><col width="6.3%"></colgroup><tr valign="top"><td><p type="p_table_l" style="margin-top: 4px" align="left"><code>WHENEVER $AA_DTEPW[X]==0 DO $AA_OVR[Z]= 100</code></p></td><td><p type="p_table_l" style="margin-top: 4px" align="left"></p> </td></tr><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Whenever the remaining distance for the partial infeed of infeed axis X in the WCS is equal to zero, then set the axial override of the oscillating axis to 100%.</p></td></tr></table></p><h4 class="Blocklabel">Next partial infeed</h4><p>When infeed is complete, a premature start of the next partial infeed must be inhibited.   </p><p>A channel-specific marker (<code>$AC_MARKER[Index]</code>) is used for this purpose. It is enabled at the end of the partial infeed (partial distance-to-go ≡ 0) and deleted when the axis leaves the reversal area. The next infeed movement is then prevented by a synchronized action.</p><p>On the basis of the given assumptions, the following instructions apply for reversal point 1:</p><a id="table_a850e866-0264-4b10-90ff-0de6b2d405ed"></a> <a id="table_6"></a> <a id="table_a850e866-0264-4b10-90ff-0de6b2d405ed"></a> <a id="table_6"></a> <p><table width="100%" cellspacing="0" cellpadding="0" class="table_invisible" border="0"><colgroup><col width="31.7%"><col width="68.3%"></colgroup><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">1. Set marker:</p>WHENEVER $AA_DTEPW[X] == 0 DO $AC_MARKER[1]=1</td></tr><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Whenever the remaining distance for the partial infeed of infeed axis X in the WCS is equal to zero, then set the bit memory with index 1 to 1.</p></td></tr><tr valign="top"><td> </td><td> </td></tr><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">2. Delete marker:</p>WHENEVER $AA_IM[Z]&lt;> $SA_OSCILL_RESERVE_POS1[Z] DO $AC_MARKER[1] = 0</td></tr><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Whenever the actual position of oscillating axis Z in the MCS is greater or less than the position of reversal point 1, then set the bit memory 1 to 0.</p></td></tr><tr valign="top"><td> </td><td> </td></tr><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">3. Inhibit infeed<b>:</b></p>WHENEVER $AC_MARKER[1]==1 DO $AA_OVR[X]=0</td></tr><tr valign="top"><td colspan="2"><p type="p_table_l" style="margin-top: 4px" align="left">Whenever bit memory 1 is the same, then set the axial override of the infeed axis X to 0%.</p></td></tr></table></p><p></p></div>
  </body>
</html>